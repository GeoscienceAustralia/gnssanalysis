import unittest
from unittest.mock import patch, mock_open
from pyfakefs.fake_filesystem_unittest import TestCase

import numpy as np
import pandas as pd

import gnssanalysis.gn_io.sp3 as sp3

# dataset is part of the IGS benchmark (modified to include non null data on clock)
input_data = b"""#dV2007  4 12  0  0  0.00000000       2 ORBIT IGS14 BHN ESOC
## 1422 345600.00000000   900.00000000 54202 0.0000000000000
+    2   G01G02  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++         8  8  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
%c M  cc GPS ccc cccc cccc cccc cccc ccccc ccccc ccccc ccccc
%c cc cc ccc ccc cccc cccc cccc cccc ccccc ccccc ccccc ccccc
%f  0.0000000  0.000000000  0.00000000000  0.000000000000000
%f  0.0000000  0.000000000  0.00000000000  0.000000000000000
%i    0    0    0    0      0      0      0      0         0
%i    0    0    0    0      0      0      0      0         0
/*   EUROPEAN SPACE OPERATIONS CENTRE - DARMSTADT, GERMANY
/* ---------------------------------------------------------
/*  SP3 FILE GENERATED BY NAPEOS BAHN TOOL  (DETERMINATION)
/* PCV:IGS14_2022 OL/AL:EOT11A   NONE     YN ORB:CoN CLK:CoN
*  2007  4 12  0  0  0.00000000
PG01  -6114.801556 -13827.040252  22049.171610 999999.999999
VG01  27184.457428  -3548.055474   5304.058806 999999.999999
PG02  12947.223282  22448.220655   6215.570741 999999.999999
VG02  -7473.756152  -4355.288568  29939.333728 999999.999999
*  2007  4 12  0 15  0.00000000
PG01  -3659.032812 -14219.662913  22339.175481 123456.999999
VG01  27295.435569  -5170.061971   1131.227754 999999.999999
PG02  12163.580358  21962.803659   8849.429007 999999.999999
VG02  -9967.334764  -6367.969150  28506.683280 999999.999999
*  2007  4 12  0 30  0.00000000
PG01  -1218.171155 -14755.013599  22252.168480 999999.999999
VG01  26855.435366  -6704.236117  -3062.394499 999999.999999
PG02  11149.555664  21314.099837  11331.977499 123456.999999
VG02 -12578.915944  -7977.396362  26581.116225 999999.999999
EOF"""

# second dataset a truncated version of file COD0OPSFIN_20242010000_01D_05M_ORB.SP3
input_data2 = b"""#dP2024  7 19  0  0  0.00000000       2 d+D   IGS20 FIT AIUB
## 2323 432000.00000000   300.00000000 60510 0.0000000000000
+   34   G01G02G03G04G05G06G07G08G09G10G11G12G13G14G15G16G17
+        G18G19G20G21G22G23G24G25G26G27G28G29G30G31G32R01R02
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++        10  4  4  5  4  4  4  6  5  4  4  4  4  4  5  4  5
++         4  5  4  4  4  4  4  4  4  6  4  6  4  4  5  6  5
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
%c M  cc GPS ccc cccc cccc cccc cccc ccccc ccccc ccccc ccccc
%c cc cc ccc ccc cccc cccc cccc cccc ccccc ccccc ccccc ccccc
%f  1.2500000  1.025000000  0.00000000000  0.000000000000000
%f  0.0000000  0.000000000  0.00000000000  0.000000000000000
%i    0    0    0    0      0      0      0      0         0
%i    0    0    0    0      0      0      0      0         0
/* Center for Orbit Determination in Europe (CODE)                              
/* Final GNSS orbits and clocks for year-day 2024-2010                          
/* Middle day of a 3-day long-arc GRE solution                                  
/* Product reference - DOI 10.48350/197025                                      
/* PCV:IGS20      OL/AL:FES2014b NONE     YN ORB:CoN CLK:CoN                    
*  2024  7 19  0  0  0.00000000
PG01   4510.358405 -23377.282442 -11792.723580    239.322216
PG02 -19585.529427  -8704.823858  16358.028672   -396.375750
PG03 -17580.234088   4691.573463  19141.243267    463.949579
PG04 -26617.740573   -946.516862   -357.173231    406.566363
PG05  10519.989071  11642.454057 -21602.301106   -180.212857
PG06   2740.107726  22949.477848  13050.231113    153.243042
PG07 -12152.989068   9271.906499 -21171.448381    -67.284723
PG08 -23564.648181  -7008.524027 -10695.029085    280.133395
PG09 -22670.253623   8239.927695 -11264.465256    278.657733
PG10   9580.520625 -23903.962622   5952.953525    -69.725084
PG11  12172.421489  23643.157258   -326.393541   -707.231762
PG12  17334.922032   -823.708469  19813.865911   -523.374443
PG13  16727.626248  13547.519770 -15930.060856    665.433543
PG14 -12686.532565  23113.995383   2015.864577    452.016655
PG15  24059.592741   4664.732321 -10971.570014    182.639915
PG16  -6877.230588 -15339.991251 -20789.984745   -232.880135
PG17 -10544.199531  13546.167670  20731.026605    674.717955
PG18  11395.390478 -10003.912563 -21773.096162   -637.936101
PG19    -91.221848  15052.899704  21730.850663    512.380157
PG20   4759.352016  20412.066571 -16337.185863    372.619575
PG21 -19969.439191 -14052.082376  12052.083047    108.053447
PG22  -7851.805614  23456.844489  10476.676398    -41.203734
PG23  16034.574849 -20014.311736  -6447.454610    276.983496
PG24  19957.601137  10937.343983  13593.650614   -483.663354
PG25  18503.862277 -12238.621370  14074.861759    498.640109
PG26   1475.737214 -23530.898479 -12009.992564    117.423098
PG27 -14637.611860 -12916.890302 -18487.558552    -31.428894
PG28  -1448.158650 -22094.490708  14658.613933   -336.951588
PG29  24922.894960  -3781.189132  -8612.199695   -588.839802
PG30  -4171.292661  19133.602125 -17670.162520   -355.440356
PG31  -9582.858249 -24150.657329   4174.829416   -226.651916
PG32   7577.135648 -14625.213465  21009.434182   -611.423040
PR01 -11174.717239  13919.992970 -18217.088128     91.816094
PR02   5986.296598   9182.597099 -22986.090345    -23.760098
*  2024  7 19  0  5  0.00000000
PG01   4796.934856 -23696.377197 -10979.751610    239.319708
PG02 -19881.646388  -9206.366139  15702.571850   -396.373498
PG03 -17231.990585   4028.826042  19602.838740    463.954491
PG04 -26611.194412  -1022.842880    595.880633    406.568667
PG05  10136.800208  12350.997157 -21386.843888   -180.212807
PG06   2450.718390  22528.454438  13825.080211    153.236129
PG07 -12588.175387   8544.963490 -21235.315069    -67.282747
PG08 -23153.571120  -7092.421087 -11502.447779    280.138208
PG09 -23081.189929   8177.801481 -10440.335865    278.662254
PG10   9739.714186 -24045.438533   5008.545199    -69.728000
PG11  12100.828204  23674.758365    628.417502   -707.233760
PG12  16927.894794   -156.593450  20175.354086   -523.375506
PG13  16123.821666  13506.143862 -16576.439914    665.434587
PG14 -12806.266956  23108.901725   1071.974280    452.019309
PG15  23667.445329   4810.788715 -11764.325180    182.641029
PG16  -6410.925819 -15949.796500 -20459.301164   -232.877069
PG17 -11294.404827  13477.778140  20374.821327    674.715594
PG18  11808.093049  -9281.574455 -21878.898484   -637.937253
PG19   -926.024078  14963.777562  21760.484912    512.381523
PG20   4496.768024  20968.671114 -15701.186882    372.619665
PG21 -20171.951734 -14415.667672  11259.651245    108.052842
PG22  -8113.879568  23715.467014   9635.144223    -41.205092
PG23  15968.691130 -19748.533800  -7367.767935    276.986193
PG24  20196.206628  11409.190382  12869.197736   -483.663786
PG25  18296.647253 -11700.764982  14777.021547    498.640196
PG26   1756.577155 -23886.875266 -11223.049448    117.421009
PG27 -13946.700542 -12958.004982 -18981.685935    -31.429176
PG28  -1093.607650 -21641.232687  15348.789400   -336.956264
PG29  25224.978997  -3692.145216  -7724.080127   -588.839284
PG30  -4576.427167  18562.149295 -18175.982398   -355.438403
PG31  -9405.141803 -24034.766821   5108.030163   -226.651713
PG32   8358.841176 -14606.846254  20714.894870   -611.422426
PR01 -11838.908273  14235.469200 -17540.792598     91.816562
PR02   5096.267067   9515.396007 -23066.803522    -23.760149
EOF
"""


# Minimal (and artifically modified) header for testing SV and SV accuracy code reading part of header parser.
# Note that comment line stripping happens before the header parser, so it is not expected to deal with comment lines.
sample_header_svs = b"""#dP2024  1 27  0  0  0.0000000      289 ORBIT IGS14 FIT  GAA
## 2298 518400.00000000   300.00000000 60336 0.0000000000000
+   30   G02G03G04G05G06G07G08G09G10G11G12G13G14G15G16G17G18
+        G19G20G21G22G23G24G25G26G28G29G30G31G32  0  0  0  0
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
+          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++        10 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15-14
++        11 15 15 15 15 15 15 15 15 15 15 15 18  0  0  0  0
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
++         0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
%c G  cc GPS ccc cccc cccc cccc cccc ccccc ccccc ccccc ccccc
%c cc cc ccc ccc cccc cccc cccc cccc ccccc ccccc ccccc ccccc
%f  1.2500000  1.025000000  0.00000000000  0.000000000000000
%f  0.0000000  0.000000000  0.00000000000  0.000000000000000
%i    0    0    0    0      0      0      0      0         0
%i    0    0    0    0      0      0      0      0         0
"""


class TestSp3(unittest.TestCase):
    @patch("builtins.open", new_callable=mock_open, read_data=input_data)
    def test_read_sp3_pOnly(self, mock_file):
        result = sp3.read_sp3("mock_path", pOnly=True)
        self.assertEqual(len(result), 6)

    @patch("builtins.open", new_callable=mock_open, read_data=input_data)
    def test_read_sp3_pv(self, mock_file):
        result = sp3.read_sp3("mock_path", pOnly=False)
        self.assertEqual(len(result), 6)
        # Ensure first epoch is correct / not skipped by incorrect detection of data start.
        # Check output of both header and data section.
        self.assertEqual(
            result.attrs["HEADER"]["HEAD"]["DATETIME"], "2007  4 12  0  0  0.00000000"
        )
        self.assertEqual(result.index[0][0], 229608000)  # Same date, as J2000

    @patch("builtins.open", new_callable=mock_open, read_data=input_data)
    def test_read_sp3_header_svs_basic(self, mock_file):
        """
        Minimal test of reading SVs from header
        """
        result = sp3.read_sp3("mock_path", pOnly=False)
        self.assertEqual(
            result.attrs["HEADER"]["SV_INFO"].shape[0], 2, "Should be two SVs in data"
        )
        self.assertEqual(
            result.attrs["HEADER"]["SV_INFO"].index[1], "G02", "Second SV should be G02"
        )
        self.assertEqual(
            result.attrs["HEADER"]["SV_INFO"].iloc[1], 8, "Second ACC should be 8"
        )

    def test_read_sp3_header_svs_detailed(self):
        """
        Test header parser's ability to read SVs and their accuracy codes correctly. Uses separate, artificial
        test header data.
        Does NOT currently test handling of large numbers of SV entries. According to SP3-d (2016), up to 999
        satellites are allowed!
        """
        # We check that negative values parse correctly, but override the default behaviour of warning about them,
        # to keep the output clean.
        result = sp3.parse_sp3_header(
            sample_header_svs, warn_on_negative_sv_acc_values=False
        )
        # Pull out SV info header section, which contains SVs and their accuracy codes
        # Note: .attrs['HEADER'] nesting gets added by parent function.
        sv_info = result["SV_INFO"]
        sv_count = sv_info.shape[0]  # Effectively len()
        self.assertEqual(
            sv_count, 30, msg="There should be 30 SVs parsed from the test data"
        )

        # Ensure no SVs are read as empty
        self.assertFalse(
            any(len(sv.strip()) == 0 for sv in sv_info.index),
            msg="No SV name should be empty",
        )

        # Focus on potential line wraparound issues
        first_sv = sv_info.index[0]
        self.assertEqual(first_sv, "G02", msg="First SV in test data should be G02")
        end_line1_sv = sv_info.index[16]
        self.assertEqual(
            end_line1_sv, "G18", msg="Last SV on test line 1 (pos 17) should be G18"
        )
        start_line2_sv = sv_info.index[17]
        self.assertEqual(
            start_line2_sv, "G19", msg="First SV on test line 2 (pos 18) should be G19"
        )
        end_line2_sv = sv_info.index[29]
        self.assertEqual(
            end_line2_sv, "G32", msg="Last SV on test line 2 (pos 30) should be G32"
        )

        # Ensure first, wrap around, and last accuracy codes came out correctly. Data is artificial to differentiate.
        first_acc = sv_info.iloc[0]
        self.assertEqual(
            first_acc, 10, msg="First accuracy code in test data should be 10"
        )
        end_line1_acc = sv_info.iloc[16]
        self.assertEqual(
            end_line1_acc,
            -14,
            msg="Accuracy code end line 1 in test data should be -14",
        )
        start_line2_acc = sv_info.iloc[17]
        self.assertEqual(
            start_line2_acc, 11, msg="First ACC on test line 2 (pos 18) should be 11"
        )
        end_line2_acc = sv_info.iloc[29]
        self.assertEqual(
            end_line2_acc, 18, msg="Last ACC on test line 2 (pos 30) should be 18"
        )

    def test_sp3_clock_nodata_to_nan(self):
        sp3_df = pd.DataFrame(
            {("EST", "CLK"): [999999.999999, 123456.789, 999999.999999, 987654.321]}
        )
        sp3.sp3_clock_nodata_to_nan(sp3_df)
        expected_result = pd.DataFrame(
            {("EST", "CLK"): [np.nan, 123456.789, np.nan, 987654.321]}
        )
        self.assertTrue(sp3_df.equals(expected_result))

    def test_sp3_pos_nodata_to_nan(self):
        """
        This test data represents four 'rows' of data, each with an X, Y and Z component of the Position vector.
        Nodata position values are indicated by all vector components being 0, as up to two components being 0 can
        represent true (if extremely improbable) values (e.g. a satellite directly below the pole would be 0,0,z
        with z being quite large).
        The expected results are arranged by column not row (the second entry is 1.0, 0.0, 1.0).
        """
        sp3_df = pd.DataFrame(
            {
                ("EST", "X"): [0.0, 1.0, 0.0, 2.0],
                ("EST", "Y"): [0.0, 0.0, 0.0, 2.0],
                ("EST", "Z"): [0.0, 1.0, 0.0, 0.0],
            }
        )
        sp3.sp3_pos_nodata_to_nan(sp3_df)
        expected_result = pd.DataFrame(
            {
                ("EST", "X"): [np.nan, 1.0, np.nan, 2.0],
                ("EST", "Y"): [np.nan, 0.0, np.nan, 2.0],
                ("EST", "Z"): [np.nan, 1.0, np.nan, 0.0],
            }
        )
        self.assertTrue(sp3_df.equals(expected_result))

    @patch("builtins.open", new_callable=mock_open, read_data=input_data)
    def test_velinterpolation(self, mock_file):
        """
        Checking if the velocity interpolation works, right now there is no data to validate, the only thing done
        is to check if the function runs without errors
        """
        result = sp3.read_sp3("mock_path", pOnly=True)
        r = sp3.getVelSpline(result)
        r2 = sp3.getVelPoly(result, 2)
        self.assertIsNotNone(r)
        self.assertIsNotNone(r2)


class TestMergeSP3(TestCase):
    def setUp(self):
        self.setUpPyfakefs()

    def test_sp3merge(self):
        # Create some fake files
        file_paths = ["/fake/dir/file1.sp3", "/fake/dir/file2.sp3"]
        self.fs.create_file(file_paths[0], contents=input_data)
        self.fs.create_file(file_paths[1], contents=input_data2)

        # Call the function to test
        result = sp3.sp3merge(sp3paths=file_paths)

        # Test that epochs, satellite, attrs data is as expected:
        epoch_index = result.index.get_level_values("J2000")
        sat_index = result.index.get_level_values("PRN")
        # Verify
        self.assertEqual(min(epoch_index), 229608000)
        self.assertEqual(max(epoch_index), 774619500)
        self.assertEqual(sat_index[0], "G01")
        self.assertEqual(sat_index[-1], "R02")
        self.assertEqual(result.attrs["HEADER"].HEAD.VERSION, "d")
        self.assertEqual(result.attrs["HEADER"].HEAD.AC, "AIES")
        self.assertEqual(result.attrs["HEADER"].HEAD.COORD_SYS, None)
        self.assertEqual(result.attrs["HEADER"].HEAD.PV_FLAG, "P")
